#!/bin/bash

# Post-tool-use hook: Tracks edited workspaces for batch processing later.
# Non-blocking, fail-safe.

# 1. Safety & Input
# Don't use set -e, it makes grep logic brittle. Handle errors manually.
tool_info=$(cat)

# 2. Extract Data (Use specific keys to avoid ambiguity)
# CLAUDE_PROJECT_DIR is injected by the environment, but fallback to CWD if missing
PROJECT_ROOT="${CLAUDE_PROJECT_DIR:-$(pwd)}"

tool_name=$(echo "$tool_info" | jq -r '.tool_name // empty')
# Ensure we handle potential absolute paths from Claude
raw_file_path=$(echo "$tool_info" | jq -r '.tool_input.file_path // empty')
session_id=$(echo "$tool_info" | jq -r '.session_id // "default"')

# 3. Fast Exit Checks
[[ ! "$tool_name" =~ ^(Edit|MultiEdit|Write)$ ]] && exit 0
[[ -z "$raw_file_path" ]] && exit 0
[[ "$raw_file_path" =~ \.(md|markdown|txt|json|lock)$ ]] && exit 0

# Normalize path to absolute, then calculate relative
if [[ "$raw_file_path" = /* ]]; then
  abs_path="$raw_file_path"
else
  abs_path="$PROJECT_ROOT/$raw_file_path"
fi

# Verify file exists (it might have been deleted or move during the Edit)
[[ ! -f "$abs_path" ]] && exit 0

# Get relative path safely
rel_path="${abs_path#$PROJECT_ROOT/}"

# 4. Setup Cache
cache_dir="$PROJECT_ROOT/.claude/tsc-cache/$session_id"
mkdir -p "$cache_dir"

# 5. Repo/Workspace Detection
detect_repo() {
    local path="$1"
    local root_folder=$(echo "$path" | cut -d'/' -f1)

    case "$root_folder" in
        # Standard Monorepo Structures
        packages|apps|libs|services|examples)
            local sub_folder=$(echo "$path" | cut -d'/' -f2)
            if [[ -n "$sub_folder" ]]; then
                echo "$root_folder/$sub_folder"
            else
                echo "$root_folder"
            fi
            ;;
        # Top-level known folders
        frontend|backend|client|server|web|api|database|prisma)
            echo "$root_folder"
            ;;
        # Root level files
        *)
            if [[ "$path" != *"/"* ]]; then
                echo "root"
            else
                echo "unknown" # Or return root_folder to be safe
            fi
            ;;
    esac
}

repo=$(detect_repo "$rel_path")
[[ "$repo" == "unknown" || -z "$repo" ]] && exit 0

repo_full_path="$PROJECT_ROOT/$repo"

# 6. Command Discovery (Aligned with your BUN/UV preference)
get_build_command() {
    local r_path="$1"

    # Prisma Special Case
    if [[ "$repo" == "database" || "$repo" == "prisma" ]]; then
        echo "cd $r_path && bun x prisma generate"
        return
    fi

    if [[ -f "$r_path/package.json" ]]; then
        # Check if build script exists safely
        if grep -q '"build":' "$r_path/package.json"; then
            echo "cd $r_path && bun run build"
            return
        fi
    fi
}

get_tsc_command() {
    local r_path="$1"

    if [[ -f "$r_path/tsconfig.json" ]]; then
        # Check for build-specific tsconfig
        if [[ -f "$r_path/tsconfig.build.json" ]]; then
            echo "cd $r_path && bun run tsc --project tsconfig.build.json --noEmit"
        elif [[ -f "$r_path/tsconfig.app.json" ]]; then
            echo "cd $r_path && bun run tsc --project tsconfig.app.json --noEmit"
        else
            echo "cd $r_path && bun run tsc --noEmit"
        fi
    fi
}

# 7. Logging (Atomic / Append Only)
# Log the raw edit event
echo "$(date +%s):$rel_path:$repo" >> "$cache_dir/edited-files.log"

# Log the repo if not already in the "session set"
# We don't care about duplicates here, we can uniq them when reading
echo "$repo" >> "$cache_dir/affected-repos.log"

# Calculate commands
build_cmd=$(get_build_command "$repo_full_path")
tsc_cmd=$(get_tsc_command "$repo_full_path")

if [[ -n "$build_cmd" ]]; then
    echo "$repo:build:$build_cmd" >> "$cache_dir/commands.log"
fi

if [[ -n "$tsc_cmd" ]]; then
    echo "$repo:tsc:$tsc_cmd" >> "$cache_dir/commands.log"
fi

# exit clean
exit 0
