#!/usr/bin/env -S uv run --script
#
# /// script
# requires-python = ">=3.13"
# dependencies = []
# ///

import json
import sys
import subprocess
import os
import re
import shutil
from pathlib import Path

# --- CONFIGURATION ---
COMMANDS = {
    "python": {
        # Format and fix imports/style
        "format": ["uv", "run", "ruff", "check", "--select", "I", "--fix"],
        "style": ["uv", "run", "ruff", "format"],
        # Lint for errors
        "lint": ["uv", "run", "ruff", "check"],
        # Typecheck
        "typecheck": ["uv", "run", "mypy"],
        # Test
        "test": ["uv", "run", "pytest"],
    },
    "typescript": {
        # Biome handles format and lint
        "format": ["bun", "run", "biome", "check", "--write", "--unsafe"],
        # Typecheck (runs on whole project usually)
        "typecheck": ["bun", "run", "tsc", "--noEmit"],
        # Test
        "test": ["bun", "test"],
    },
    "bash": {
        "lint": ["shellcheck"],
    },
    "markdown": {"format": ["bun", "run", "prettier", "--write"]},
}


# --- HELPER: MARKDOWN REGEX FORMATTER (Fallback) ---
def detect_markdown_language(code: str) -> str:
    s = code.strip()
    if re.search(r"^\s*[{\[]", s):
        return "json"
    if re.search(r"^\s*def\s+\w+\s*\(", s, re.M) or re.search(
        r"^\s*(import|from)\s+\w+", s, re.M
    ):
        return "python"
    if re.search(r"\b(function\s+\w+\s*\(|const\s+\w+\s*=)", s) or re.search(
        r"=>|console\.(log|error)", s
    ):
        return "javascript"
    if re.search(r"^#!.*\b(bash|sh)\b", s, re.M) or re.search(
        r"\b(if|then|fi|for|in|do|done)\b", s
    ):
        return "bash"
    if re.search(r"\b(SELECT|INSERT|UPDATE|DELETE|CREATE)\s+", s, re.I):
        return "sql"
    return "text"


def format_markdown_regex(path: Path) -> tuple[bool, str, bool]:
    """Fallback formatter if Prettier is missing."""
    try:
        content = path.read_text(encoding="utf-8")

        def add_lang_to_fence(match):
            indent, info, body, closing = match.groups()
            if not info.strip():
                lang = detect_markdown_language(body)
                return f"{indent}```{lang}\n{body}{closing}\n"
            return match.group(0)

        fence_pattern = r"(?ms)^([ \t]{0,3})```([^\n]*)\n(.*?)(\n\1```)\s*$"
        formatted = re.sub(fence_pattern, add_lang_to_fence, content)
        formatted = re.sub(r"\n{3,}", "\n\n", formatted)  # Fix excessive newlines

        if formatted != content:
            path.write_text(formatted.rstrip() + "\n", encoding="utf-8")
            print(
                f"✓ Fixed markdown formatting (Regex) in {path.name}", file=sys.stderr
            )
        return True, "", False
    except Exception as e:
        return False, f"❌ MARKDOWN REGEX FAILED:\n{e}", True


# --- SUBPROCESS RUNNER ---
def run_step(name: str, cmd_args: list[str], cwd: str) -> tuple[bool, str, bool]:
    """
    Returns (success_bool, output_string, is_real_failure)
    """
    try:
        # Check if executable exists to avoid messy python tracebacks
        exe = cmd_args[0]
        if not shutil.which(exe) and not os.path.exists(os.path.join(cwd, exe)):
            pass

        result = subprocess.run(
            cmd_args,
            cwd=cwd,
            capture_output=True,
            text=True,
        )

        # HARDENING:
        # Some tools (like ruff) might exit 0 but print warnings to stderr.
        # Others might panic (rust errors) but we might want to ignore them if they aren't code errors.

        if result.returncode != 0:
            stderr_output = result.stderr.strip()
            stdout_output = result.stdout.strip()

            # Ignore specific internal toolchain errors that aren't user code errors
            if "failed to deserialize diagnostic data" in stderr_output:
                # This is an internal tool crash, not a code error.
                # We log it but return True so we don't block Claude.
                print(
                    f"⚠️  {name.upper()} TOOL ERROR (Ignored): Internal JSON mismatch",
                    file=sys.stderr,
                )
                return True, "", False

            output = (
                f"❌ {name.upper()} FAILED:\n{stdout_output}\n{stderr_output}".strip()
            )
            return False, output, True

        return True, "", False
    except FileNotFoundError:
        print(
            f"⚠️  {name.upper()} SKIPPED: Command '{cmd_args[0]}' not found",
            file=sys.stderr,
        )
        return True, "", False


# --- LANGUAGE HANDLERS ---
def handle_python(path: Path, rel_path: str, project_dir: str, errors: list[str]):
    # Format & Style
    run_step("fmt", COMMANDS["python"]["format"] + [rel_path], project_dir)
    run_step("style", COMMANDS["python"]["style"] + [rel_path], project_dir)

    # Lint
    success, out, is_real = run_step(
        "lint", COMMANDS["python"]["lint"] + [rel_path], project_dir
    )
    if not success and is_real:
        errors.append(out)

    # Typecheck
    success, out, is_real = run_step(
        "mypy", COMMANDS["python"]["typecheck"] + [rel_path], project_dir
    )
    if not success and is_real:
        errors.append(out)

    # Tests
    if "test" in path.name or path.name.startswith("test_"):
        success, out, is_real = run_step(
            "test", COMMANDS["python"]["test"] + [rel_path], project_dir
        )
        if not success and is_real:
            errors.append(out)


def handle_typescript(path: Path, rel_path: str, project_dir: str, errors: list[str]):
    # Format & Lint (Biome)
    success, out, is_real = run_step(
        "biome", COMMANDS["typescript"]["format"] + [rel_path], project_dir
    )
    if not success and is_real:
        errors.append(out)

    # Typecheck (TSC needs project root, doesn't take single file arg easily without hacks)
    success, out, is_real = run_step(
        "tsc", COMMANDS["typescript"]["typecheck"], project_dir
    )
    if not success and is_real:
        errors.append(out)

    # Test
    if ".test." in path.name or ".spec." in path.name:
        success, out, is_real = run_step(
            "test", COMMANDS["typescript"]["test"] + [rel_path], project_dir
        )
        if not success and is_real:
            errors.append(out)


def handle_bash(path: Path, rel_path: str, project_dir: str, errors: list[str]):
    success, out, is_real = run_step(
        "shellcheck", COMMANDS["bash"]["lint"] + [rel_path], project_dir
    )
    if not success and is_real:
        errors.append(out)


def handle_markdown(path: Path, rel_path: str, project_dir: str, errors: list[str]):
    # Try Prettier first
    success, out, is_real = run_step(
        "prettier", COMMANDS["markdown"]["format"] + [rel_path], project_dir
    )

    # If prettier failed (likely not installed or config error), try the regex fallback
    if not success:
        # But only if it wasn't a syntax error in the MD itself.
        # Usually prettier exits 1 on syntax error, but 127 if not found.
        # We'll just run the regex fallback regardless if Prettier didn't work perfectly.
        format_markdown_regex(path)


# --- ROUTER ---
def main():
    try:
        input_data = json.load(sys.stdin)
    except json.JSONDecodeError:
        sys.exit(0)

    # 1. Context Setup
    cwd = input_data.get("cwd", ".")
    # CLAUDE_PROJECT_DIR is reliable for hooks
    project_dir = os.environ.get("CLAUDE_PROJECT_DIR", cwd)

    # 2. Validate Tool Success
    tool_response = input_data.get("tool_response", {})
    if not tool_response.get("success", False):
        sys.exit(0)

    # 3. Path Resolution
    tool_input = input_data.get("tool_input", {})
    file_path_str = tool_input.get("file_path")
    if not file_path_str:
        sys.exit(0)

    full_path = Path(file_path_str)
    if not full_path.is_absolute():
        full_path = Path(project_dir) / full_path

    if not full_path.exists():
        sys.exit(0)

    # Create a relative path string for cleaner linter output
    try:
        rel_path = str(full_path.relative_to(project_dir))
    except ValueError:
        rel_path = str(full_path)

    # 4. Execution
    errors = []
    suffix = full_path.suffix.lower()

    if suffix == ".py":
        handle_python(full_path, rel_path, project_dir, errors)
    elif suffix in [".ts", ".tsx", ".js", ".jsx"]:
        handle_typescript(full_path, rel_path, project_dir, errors)
    elif suffix == ".sh":
        handle_bash(full_path, rel_path, project_dir, errors)
    elif suffix in [".md", ".mdx"]:
        handle_markdown(full_path, rel_path, project_dir, errors)

    # 5. Feedback
    if errors:
        output = {
            "decision": "block",
            "reason": "\n\n".join(errors),
            "hookSpecificOutput": {
                "hookEventName": "PostToolUse",
                # We can also append context silently if we didn't want to block
                # "additionalContext": ...
            },
        }
        print(json.dumps(output))
        sys.exit(0)

    sys.exit(0)


if __name__ == "__main__":
    main()
